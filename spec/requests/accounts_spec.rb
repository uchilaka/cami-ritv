# frozen_string_literal: true

require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe '/accounts', type: :request, real_world_data: true do
  let!(:phone_data) { sample_phone_numbers.sample }

  let(:display_name) { Faker::Company.name }
  let(:email) { Faker::Internet.email }
  let(:slug) { Faker::Internet.slug }
  let(:tax_id) { Faker::Company.swedish_organisation_number }
  let(:metadata) { { 'echo' => 'ack' } }
  let(:readme) { Faker::Lorem.paragraph }

  # This should return the minimal set of attributes required to create a valid
  # Account. As you add validations to Account, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) do
    skip('Add a hash of attributes valid for your model')
  end

  let(:invalid_attributes) do
    skip('Add a hash of attributes invalid for your model')
  end

  xdescribe 'GET /index' do
    let(:user) { Fabricate :user }
    let(:account) { Fabricate :account, users: [user] }

    before do
      sign_in user
    end

    it 'renders a successful response' do
      get accounts_url
      expect(response).to be_successful
    end
  end

  xdescribe 'GET /new' do
    let(:user) { Fabricate :user }

    before do
      sign_in user
    end

    it 'renders a successful response' do
      get new_account_url
      expect(response).to be_successful
    end
  end

  xdescribe 'GET /show' do
    context 'with a signed in user' do
      let(:user) { Fabricate :user }

      before do
        sign_in user
      end

      context 'accessing an authorized account' do
        let(:account) { Fabricate :account, users: [user] }

        context 'with the default format' do
          it 'renders a successful response' do
            get account_url(account)
            expect(response).to be_successful
          end
        end

        context 'with format = json' do
          let(:data) { JSON.parse(response.body) }
          let(:expected_actions) do
            {
              'back' => {
                'domId' => anything,
                'httpMethod' => 'GET',
                'label' => 'Back to Accounts',
                'url' => accounts_url(locale: 'en')
              },
              'edit' => {
                'domId' => anything,
                'httpMethod' => 'GET',
                'label' => 'Edit',
                'url' => account_url(account, locale: 'en')
              },
              'delete' => {
                'domId' => anything,
                'httpMethod' => 'DELETE',
                'label' => 'Delete',
                'url' => account_url(account, format: :json, locale: 'en')
              },
              'show' => {
                'domId' => anything,
                'httpMethod' => 'GET',
                'label' => 'Account details',
                'url' => account_url(account, locale: 'en')
              }
              # ,'transactionsIndex' => {
              #   'httpMethod' => 'GET',
              #   'label' => 'Transactions',
              #   'url' => account_invoices_url(account)
              # },
            }
          end

          before do
            sign_in user
            allow(VirtualOfficeManager).to \
              receive(:default_url_options)
                .and_return(host: 'www.example.com', locale: 'en')
            get account_url(account, format: :json)
          end

          shared_examples 'an actionable resource' do |action_key, list_index|
            it "with the expected '#{action_key}' action hash" do
              expect(data.dig('actions', action_key)).to \
                match(hash_including(expected_actions[action_key]))
            end

            it "with the expected '#{action_key}' action hash at [#{list_index}] in the actions list" do
              expect(data.dig('actionsList', list_index)).to \
                match(hash_including(expected_actions[action_key]))
            end
          end

          it 'renders a successful response' do
            expect(response).to be_successful
          end

          it 'returns the display name' do
            expect(data['displayName']).to eq(account.display_name)
          end

          it 'returns the account ID' do
            expect(data['id']).to eq(account.id.to_s)
          end

          it_should_behave_like 'an actionable resource', 'back', 0
          it_should_behave_like 'an actionable resource', 'delete', 1
          it_should_behave_like 'an actionable resource', 'edit', 2
          it_should_behave_like 'an actionable resource', 'show', 3

          it 'returns the account slug' do
            expect(data['slug']).to eq(account.slug)
          end

          it 'returns the account status' do
            expect(data['status']).to eq(account.status)
          end

          context 'when the account is a business', skip: 'This is going away ...literally! HYHTBOY? IYNYN ðŸ˜œ' do
            let(:account) { Fabricate :business, users: [user] }

            it 'returns the tax ID' do
              expect(data['taxId']).to eq(account.tax_id)
            end

            context 'with invoices' do
              let(:email) { Faker::Internet.email }
              let(:account) do
                Fabricate :account_with_invoices,
                          type: 'Business',
                          users: [user],
                          invoices: [Fabricate(:invoice), Fabricate(:invoice)]
              end

              it 'returns the invoices' do
                expect(data['invoices']).not_to be_nil
              end
            end

            pending 'with a profile'

            pending 'without a profile'
          end

          context 'when the account is an individual', skip: 'This is going away ...literally! HYHTBOY? IYNYN ðŸ˜œ' do
            let(:account) { Fabricate :individual, users: [user] }

            it 'returns the email' do
              expect(data['email']).to eq(account.email)
            end

            context 'with several profiles' do
              let(:account) { Fabricate :individual_with_profiles, users: [user] }

              it 'returns the profiles' do
                expect(data['profiles']).to be_an(Array)
                expect(data['profiles'].count).to eq(account.profiles.count)
              end
            end

            pending 'with 1 profile'
          end
        end
      end

      context 'accessing an unauthorized account' do
        let(:account) { Fabricate :account }

        context 'with the default format' do
          pending 'redirects to the sign in page'
        end

        context 'with format = json' do
          pending 'returns a 401 status code'
        end
      end
    end

    context 'without a signed in user' do
      context 'accessing an account' do
        let(:account) { Fabricate :account }

        context 'with the default format' do
          pending 'redirects to the sign in page'
        end

        context 'with format = json' do
          before { get account_url(account, format: :json) }

          it 'returns a 401 status code' do
            get account_url(account, format: :json)
            expect(response).to have_http_status(:unauthorized)
          end

          it 'returns an error message' do
            get account_url(account, format: :json)
            expect(response.body).to include('You need to sign in or sign up before continuing.')
          end
        end
      end
    end
  end

  xdescribe 'POST /create' do
    context 'with an authorized user' do
      let(:user) { Fabricate :user }

      before do
        sign_in user
      end

      context 'and valid account parameters' do
        let(:params) do
          {
            account: {
              display_name:,
              email:,
              slug:,
              tax_id:,
              metadata:,
              phone: phone_data[:full_e164],
              status: 'active'
            },
            profile: {
              'country_alpha2' => phone_data[:country]
            }
          }
        end

        subject { Account.find_by_slug params.dig(:account, :slug) }

        context 'has side effect(s) of' do
          it 'creating a new Account' do
            expect { post(accounts_url, params:) }.to change(Account, :count).by(1)
          end

          it 'redirecting to the created account' do
            post(accounts_url, params:)
            expect(response).to redirect_to(account_url(subject))
          end
        end

        context 'when format = json' do
          it 'returns the expected HTTP status' do
            post accounts_url, params: params.merge(format: :json)
            expect(response).to have_http_status(:created)
          end
        end

        context 'attributes' do
          before { post(accounts_url, params:) }

          context '#email' do
            it { expect(subject.email).to eq(params.dig(:account, :email)) }
          end

          context '#phone' do
            let(:parsed_number) { Phonelib.parse(phone_data[:full_e164]) }

            it do
              expect(subject.phone['full_e164']).to \
                eq(parsed_number.full_e164)
            end
          end

          context '#status' do
            it { expect(subject.status).to eq(params.dig(:account, :status)) }
          end

          context '#tax_id' do
            it { expect(subject.tax_id).to eq(params.dig(:account, :tax_id)) }
          end

          context '#slug' do
            it { expect(subject.slug).to eq(params.dig(:account, :slug)) }
          end

          context '#display_name' do
            it { expect(subject.display_name).to eq(params.dig(:account, :display_name)) }
          end

          context '#metadata' do
            it do
              expect(subject.metadata).to \
                match(params.dig(:account, :metadata).merge(params[:profile]))
            end

            it do
              expect(subject.metadata).to \
                match(hash_including(params.dig(:account, :metadata)))
            end
          end
        end
      end

      context 'and no account parameters' do
        pending 'returns the expected error message(s)'
        pending 'returns the expected status'
      end

      context 'and no profile parameters' do
        pending 'creates the account'
        pending 'does NOT create the account profile'
      end
    end
  end

  xdescribe 'GET /edit' do
    let(:user) { Fabricate :user }
    let(:account) { Fabricate :account, users: [user], status: 'active' }

    before { sign_in user }

    it 'renders a successful response' do
      get edit_account_url(account)
      expect(response).to be_successful
    end
  end

  xdescribe 'PATCH /update' do
    context 'with an authorized user' do
      let!(:current_phone_data) { Phonelib.parse('+2347129248348', 'NG') }
      let!(:account) do
        Fabricate :account,
                  phone: {
                    full_e164: current_phone_data.full_e164,
                    country: current_phone_data.country
                  },
                  metadata: {
                    marco: 'polo',
                    address: {
                      street: '123 Main St',
                      city: 'Anytown',
                      state: 'AS',
                      postal_code: '12345'
                    },
                    country_alpha2: current_phone_data.country
                  },
                  users: [user],
                  status: 'guest'
      end

      # TODO: Implement access controls for models informed by (Pundit + Rolify) policies
      let(:user) { Fabricate :user }

      before do
        sign_in user
      end

      context 'and valid account parameters' do
        let(:params) do
          {
            account: {
              display_name:,
              email:,
              slug:,
              tax_id:,
              metadata:,
              phone: phone_data[:full_e164],
              status: 'guest'
            },
            profile: {
              'country_alpha2' => phone_data[:country]
            }
          }
        end

        subject { account.reload }

        context 'has side effect(s) of' do
          it 'NOT creating a new Account' do
            expect do
              patch(account_url(account), params:)
            end.not_to change(Account, :count)
          end

          it 'redirecting to the created account' do
            patch(account_url(account), params:)
            expect(response).to redirect_to(account_url(subject))
          end

          context 'when format = json' do
            it 'returns the expected HTTP status' do
              patch account_url(account), params: params.merge(format: :json)
              expect(response).to have_http_status(:ok)
            end
          end
        end

        context 'attributes' do
          let(:account_attributes) { params[:account] }
          let(:profile_attributes) { params[:profile] }

          before do
            patch account_url(account), params: params.merge(format: :json)
          end

          context '#email' do
            pending 'does NOT update the email address'
          end

          context '#phone' do
            let(:parsed_number) { Phonelib.parse(phone_data[:full_e164]) }

            it do
              expect(subject.phone['full_e164']).to \
                eq(parsed_number.full_e164)
            end
          end

          context '#status' do
            it { expect(subject.status).to eq(account_attributes[:status]) }
          end

          context '#tax_id' do
            it { expect(subject.tax_id).to eq(account_attributes[:tax_id]) }
          end

          context '#type' do
            pending 'does NOT update the account type'
          end

          context '#slug' do
            pending 'does NOT update the account slug'
          end

          context '#display_name' do
            it { expect(subject.display_name).to eq(account_attributes[:display_name]) }
          end

          context '#metadata' do
            it do
              expect(subject.metadata).to \
                match(hash_including(account_attributes[:metadata].merge(profile_attributes)))
            end
          end
        end
      end

      context 'and no account parameters' do
        pending 'returns the expected error message(s)'
        pending 'returns the expected status'
      end

      context 'and no profile parameters' do
        pending 'updates the account'
        pending 'does NOT update the account profile'
      end

      context 'and slug in the payload' do
        pending 'does NOT update the account slug'
      end

      context 'and type in the payload' do
        pending 'does NOT update the account type'
      end
    end

    xcontext 'with valid parameters' do
      let(:new_attributes) do
        skip('Add a hash of attributes valid for your model')
      end

      it 'updates the requested account' do
        account = Account.create! valid_attributes
        patch account_url(account), params: { account: new_attributes }
        account.reload
        skip('Add assertions for updated state')
      end

      it 'redirects to the account' do
        account = Account.create! valid_attributes
        patch account_url(account), params: { account: new_attributes }
        account.reload
        expect(response).to redirect_to(account_url(account))
      end
    end

    xcontext 'with invalid parameters' do
      it "renders a response with 422 status (i.e. to display the 'edit' template)" do
        account = Account.create! valid_attributes
        patch account_url(account), params: { account: invalid_attributes }
        expect(response).to have_http_status(:unprocessable_entity)
      end
    end
  end

  describe 'DELETE /destroy' do
    it 'destroys the requested account' do
      account = Account.create! valid_attributes
      expect do
        delete account_url(account)
      end.to change(Account.kept, :count).by(-1)
    end

    it 'redirects to the accounts list' do
      account = Account.create! valid_attributes
      delete account_url(account)
      expect(response).to redirect_to(accounts_url)
    end
  end
end
